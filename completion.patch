diff --unified --recursive --text old/scripts/docopt-wordlist.bash new/scripts/docopt-wordlist.bash
--- old/scripts/docopt-wordlist.bash	2022-07-24 23:58:01.000000000 -0400
+++ new/scripts/docopt-wordlist.bash	2022-07-30 22:26:58.216098328 -0400
@@ -1,19 +1,3 @@
-# This is your basic tab completion that will work well with commands that
-# have only one usage (i.e., no distinct sub-commands).
-#
-# Completion works by simply taking the command name and running `$cmd --help`
-# to get the usage (which is then parsed for possible completions).
-function _docopt_wordlist {
-  if [ -z "$DOCOPT_WORDLIST_BIN" ]; then
-    DOCOPT_WORDLIST_BIN=/usr/local/bin/docopt-wordlist
-  fi
-
-  cword=$(_get_cword)
-  cmd="${COMP_WORDS[0]}"
-  wordlist=$("$cmd" --help 2>&1 | "$DOCOPT_WORDLIST_BIN")
-  gen "$cword" "$wordlist"
-}
-
 # This is a fancier version of the above that supports commands that have
 # multiple sub-commands (i.e., distinct usages like Cargo).
 #
@@ -37,20 +21,16 @@
 # As a special case, if only the initial command has been typed, then the
 # sub-commands (taken from `$cmd --list`) are added to the wordlist.
 function _docopt_wordlist_commands {
-  if [ -z "$DOCOPT_WORDLIST_BIN" ]; then
-    DOCOPT_WORDLIST_BIN=/usr/local/bin/docopt-wordlist
-  fi
-
   cword=$(_get_cword)
   if [ "$COMP_CWORD" = 1 ]; then
     cmd="${COMP_WORDS[0]}"
-    wordlist=$("$cmd" --help 2>&1 | "$DOCOPT_WORDLIST_BIN")
+    wordlist=$("$cmd" --help 2>&1 | docopt-wordlist)
     wordlist+=" $("$cmd" --list | egrep '^ +\w' | awk '{print $1}')"
     gen "$cword" "$wordlist"
   else
     for ((i="$COMP_CWORD"; i >= 1; i++)); do
       cmd="${COMP_WORDS[@]::$i}"
-      wordlist=$($cmd --help 2>&1 | "$DOCOPT_WORDLIST_BIN")
+      wordlist=$($cmd --help 2>&1 | docopt-wordlist)
       if [ $? = 0 ]; then
         gen "$cword" "$wordlist"
         break
@@ -77,3 +57,4 @@
     fi
   fi
 }
+complete -F _docopt_wordlist_commands qsv
